@page "/"

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient;

<div id="controls">
    <select @bind="_selectedRom">
        <option>-- Select a ROM --</option>
        @foreach (var rom in _roms)
        {
            <option value="@rom">@rom</option>
        }
    </select>
    <button @onclick="LoadRom">Load</button>

    <label for="tickInterval">Tick interval (ms)</label>
    <input type="number" min="1" @bind="_tickInterval" id="tickInterval" />
    <button @onclick="SetCPUInterval">Set Interval</button>
</div>

<div id="main-canvas-container" class="canvas-container">
    <CanvasManager @ref="_canvasManager" />
</div>

@code{
    CanvasManager _canvasManager;
    IRenderContext _mainRenderContext;

    CanvasBase _offscreenCanvas;
    IRenderContext _offscreenRenderContext;

    int _renderTarget;
    byte[] _frameBuffer;

    int _canvasWidth = 800;
    int _canvasHeight = 400;

    Cpu _cpu;
    State _state;
    Interfaces _interfaces;

    System.Timers.Timer _cpuTickTimer;
    int _tickInterval = 10; // milliseconds
    int _instructionsPerSecond = 400; // default IPS for web

    string[] _roms = new[]{
        "15PUZZLE",
        "BRIX",
        "HIDDEN",
        "MAZE",
        "PONG",
        "SYZYGY",
        "TICTAC",
        "VERS",
        "BLINKY",
        "CONNECT4",
        "INVADERS",
        "MERLIN",
        "PONG2",
        "TANK",
        "UFO",
        "WIPEOFF",
        "BLITZ",
        "GUESS",
        "KALEID",
        "MISSILE",
        "PUZZLE",
        "TETRIS",
        "VBRIX"
    };
    string _selectedRom;

    private readonly Dictionary<int, Core.Keys> _keyMappings = new Dictionary<int, Core.Keys>() {
            { 49, Core.Keys.Number1 }, // 1
            { 50, Core.Keys.Number2 }, // 2
            { 51, Core.Keys.Number3 }, // 3
            { 52, Core.Keys.C }, // 4
            { 81, Core.Keys.Number4 }, // q
            { 87, Core.Keys.Number5 }, // w
            { 69, Core.Keys.Number6 }, // e
            { 82, Core.Keys.D }, // r
            { 65, Core.Keys.Number7 }, // a
            { 83, Core.Keys.Number8 }, // s
            { 68, Core.Keys.Number9 }, // d
            { 70, Core.Keys.E }, // f
            { 90, Core.Keys.A }, // z
            { 88, Core.Keys.Number0 }, // x
            { 67, Core.Keys.B }, // c
            { 86, Core.Keys.F } // v
    };

    private async Task LoadRom()
    {
        _cpuTickTimer.Enabled = false;

        if (string.IsNullOrWhiteSpace(_selectedRom))
            return;

        var romUrl = $"roms/{_selectedRom}";
        using var response = await HttpClient.GetAsync(romUrl);
        if (!response.IsSuccessStatusCode)
        {
            Console.WriteLine($"Failed to load ROM from {romUrl}");
            return;
        }

        using var romData = await response.Content.ReadAsStreamAsync();
        _state.LoadRom(romData);

        _cpuTickTimer.Enabled = true;
    }

    private void UpdateFrame(VideoBuffer screen)
    {
        for (int col = 0; col != Chip8Emulator.Core.Constants.SCREEN_WIDTH; col++)
            for (int row = 0; row != Chip8Emulator.Core.Constants.SCREEN_HEIGHT; row++)
            {
                var color = screen[col, row] ? (byte)255 : (byte)0;
                int index = (row * Chip8Emulator.Core.Constants.SCREEN_WIDTH + col) * 4;
                _frameBuffer[index + 0] = color; // R
                _frameBuffer[index + 1] = color; // G
                _frameBuffer[index + 2] = color; // B
                _frameBuffer[index + 3] = 255;   // A
            }

        _offscreenRenderContext.PutImageData(_renderTarget, _frameBuffer, 0, 0);
    }

    private void SetCPUInterval()
    => _cpuTickTimer.Interval = _tickInterval;

    private void OnMainCanvasReady(CanvasBase canvas)
    {
        _mainRenderContext = canvas.RenderContext;
        _mainRenderContext.ImageSmoothingEnabled = false;
    }

    private void OnMainCanvasFrameReady(float timestamp)
    {
        _mainRenderContext.ClearRect(0, 0, _canvasWidth, _canvasHeight);
        if (_offscreenCanvas != null)
            _mainRenderContext.DrawImage(_offscreenCanvas.ElementReference,
                0, 0, Chip8Emulator.Core.Constants.SCREEN_WIDTH, Chip8Emulator.Core.Constants.SCREEN_HEIGHT,
                0, 0, _canvasWidth, _canvasHeight);
    }

    private async ValueTask OnOffscreenCanvasReady(CanvasBase canvas)
    {
        _offscreenCanvas = canvas;
        _offscreenRenderContext = canvas.RenderContext;
        _renderTarget = await _offscreenRenderContext.CreateImageDataAsync(Chip8Emulator.Core.Constants.SCREEN_WIDTH, Chip8Emulator.Core.Constants.SCREEN_HEIGHT);
        _frameBuffer = new byte[Chip8Emulator.Core.Constants.SCREEN_WIDTH * Chip8Emulator.Core.Constants.SCREEN_HEIGHT * 4];
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender)
            return;

        _canvasManager.CreateCanvas("mainCanvas", new CanvasCreationOptions()
        {
            Width = _canvasWidth,
            Height = _canvasHeight,
            Hidden = false,
            OnCanvasReady = this.OnMainCanvasReady,
            OnFrameReady = this.OnMainCanvasFrameReady,
            OnKeyDown = this.OnKeyDown,
            OnKeyUp = this.OnKeyUp
        });

        _canvasManager.CreateCanvas("offscreenCanvas", new CanvasCreationOptions()
        {
            Width = Chip8Emulator.Core.Constants.SCREEN_WIDTH,
            Height = Chip8Emulator.Core.Constants.SCREEN_HEIGHT,
            Hidden = true,
            OnCanvasReadyAsync = this.OnOffscreenCanvasReady
        });

        _interfaces = new(
            new LambdaRenderer(data => UpdateFrame(data)),
            new BlazorSoundPlayer(JsRuntime),
            new Input());
        _state = new();

        _cpu = new Cpu(_interfaces);

        _cpuTickTimer = new System.Timers.Timer();
        this.SetCPUInterval();
        _cpuTickTimer.Elapsed += (s, e) =>
        {
            double elapsedSeconds = _tickInterval / 1000.0;
            _cpu.Update(_state, elapsedSeconds, _instructionsPerSecond);
        };
    }

    public void OnKeyDown(KeyboardPressEvent evt)
    {
        if (_keyMappings.ContainsKey(evt.KeyCode))
            _interfaces.Input.SetKeyDown(_keyMappings[evt.KeyCode]);
    }

    public void OnKeyUp(KeyboardPressEvent evt)
    {
        if (_keyMappings.ContainsKey(evt.KeyCode))
            _interfaces.Input.SetKeyUp(_keyMappings[evt.KeyCode]);
    }
}
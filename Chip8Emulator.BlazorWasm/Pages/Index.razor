@page "/"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient;

<div id="canvas-container">
    <BECanvas Width="@_canvasWidth" Height="@_canvasHeight" @ref="_canvasReference"></BECanvas>
</div>

@code{
    BECanvasComponent _canvasReference = null;
    Canvas2DContext _outputCanvasContext;

    int _canvasWidth = 800;
    int _canvasHeight = 400;

    Core.Cpu _cpu;
    Core.IRenderer _renderer;

    bool[,] _currFrame;

    private readonly Dictionary<int, Core.Keys> _keyMappings = new Dictionary<int, Core.Keys>() {
            { 49, Core.Keys.Number1 }, // 1
            { 50, Core.Keys.Number2 }, // 2
            { 51, Core.Keys.Number3 }, // 3
            { 52, Core.Keys.C }, // 4
            { 81, Core.Keys.Number4 }, // q
            { 87, Core.Keys.Number5 }, // w
            { 69, Core.Keys.Number6 }, // e
            { 82, Core.Keys.D }, // r
            { 65, Core.Keys.Number7 }, // a
            { 83, Core.Keys.Number8 }, // s
            { 68, Core.Keys.Number9 }, // d
            { 70, Core.Keys.E }, // f
            { 90, Core.Keys.A }, // z
            { 88, Core.Keys.Number0 }, // x
            { 67, Core.Keys.B }, // c
            { 86, Core.Keys.F } // v
        };

    private async Task RenderFrame()
    {
        if (null == _currFrame) return;
        var spriteWidth = _canvasWidth / Chip8Emulator.Core.Cpu.SCREEN_WIDTH;
        var spriteHeight = _canvasHeight / Chip8Emulator.Core.Cpu.SCREEN_HEIGHT;

        for (int col = 0; col != Chip8Emulator.Core.Cpu.SCREEN_WIDTH; col++)
            for (int row = 0; row != Chip8Emulator.Core.Cpu.SCREEN_HEIGHT; row++)
            {
                if (!_currFrame[col, row])
                    continue;

                await _outputCanvasContext.SetFillStyleAsync("green");
                await _outputCanvasContext.FillRectAsync(col * spriteWidth, row* spriteHeight, spriteWidth, spriteHeight);
            }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        _renderer = new Chip8Emulator.Core.LambdaRenderer(data => _currFrame = data, ()=> RenderFrame());
        _cpu = new Core.Cpu(_renderer, new Chip8Emulator.Core.DefaultSoundPlayer());

        var romData = await HttpClient.GetStreamAsync("roms/PONG");
        await _cpu.LoadAsync(romData);

        _outputCanvasContext = await _canvasReference.CreateCanvas2DAsync();
        await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async ValueTask GameLoop(float timeStamp, int width, int height)
    {
        _canvasWidth = width;
        _canvasHeight = height;

        _cpu.Tick();

        await _outputCanvasContext.ClearRectAsync(0, 0, _canvasWidth, _canvasHeight);
        _renderer.Render();
    }

    [JSInvokable]
    public void OnKeyDown(int keyCode) {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyDown(_keyMappings[keyCode]);
    }

    [JSInvokable]
    public void OnKeyUp(int keyCode) {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyUp(_keyMappings[keyCode]);
    }
}
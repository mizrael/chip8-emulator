@page "/"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient;

<div id="roms-container">
    <select @bind="_selectedRom">
        <option>-- Select a ROM --</option>
        @foreach(var rom in _roms){
            <option value="@rom">@rom</option>
        }
    </select>
    <button @onclick="LoadRom">Load</button>
</div>

<div id="main-canvas-container" class="canvas-container">
    <BECanvas Width="@_canvasWidth" Height="@_canvasHeight" @ref="_canvasReference"></BECanvas>
</div>

<div class="canvas-container">
    <BECanvas Width="@_canvasWidth" Height="@_canvasHeight" @ref="_offscreenCanvasReference"></BECanvas>
</div>

@code{
    BECanvasComponent _canvasReference = null;
    Canvas2DContext _outputCanvasContext;

    BECanvasComponent _offscreenCanvasReference;
    Canvas2DContext _offscreenCanvasContext;

    int _canvasWidth = 800;
    int _canvasHeight = 400;

    Core.Cpu _cpu;
    Core.IRenderer _renderer;

    bool[,] _currFrame;

    string[] _roms = new[]{
        "15PUZZLE",        
        "BRIX",
        "HIDDEN",
        "MAZE",
        "PONG",
        "SYZYGY",
        "TICTAC",
        "VERS",
        "BLINKY",
        "CONNECT4",
        "INVADERS",
        "MERLIN",
        "PONG2",
        "TANK",
        "UFO",
        "WIPEOFF",
        "BLITZ",
        "GUESS",
        "KALEID",
        "MISSILE",
        "PUZZLE",
        "TETRIS",
        "VBRIX"
    };
    string _selectedRom;

    private readonly Dictionary<int, Core.Keys> _keyMappings = new Dictionary<int, Core.Keys>() {
            { 49, Core.Keys.Number1 }, // 1
            { 50, Core.Keys.Number2 }, // 2
            { 51, Core.Keys.Number3 }, // 3
            { 52, Core.Keys.C }, // 4
            { 81, Core.Keys.Number4 }, // q
            { 87, Core.Keys.Number5 }, // w
            { 69, Core.Keys.Number6 }, // e
            { 82, Core.Keys.D }, // r
            { 65, Core.Keys.Number7 }, // a
            { 83, Core.Keys.Number8 }, // s
            { 68, Core.Keys.Number9 }, // d
            { 70, Core.Keys.E }, // f
            { 90, Core.Keys.A }, // z
            { 88, Core.Keys.Number0 }, // x
            { 67, Core.Keys.B }, // c
            { 86, Core.Keys.F } // v
    };

    private async Task LoadRom(){
        if(string.IsNullOrWhiteSpace(_selectedRom))
            return;
        var romData = await HttpClient.GetStreamAsync($"roms/{_selectedRom}");
        await _cpu.LoadAsync(romData);
    }

    private async Task UpdateFrame(bool[,] data){
        await _offscreenCanvasContext.ClearRectAsync(0, 0, _canvasWidth, _canvasHeight);

         _currFrame = data;

        if (null == _currFrame) 
            return;

        var spriteWidth = _canvasWidth / Chip8Emulator.Core.Cpu.SCREEN_WIDTH;
        var spriteHeight = _canvasHeight / Chip8Emulator.Core.Cpu.SCREEN_HEIGHT;

        await _offscreenCanvasContext.BeginBatchAsync();

        await _offscreenCanvasContext.SetFillStyleAsync("green");

        for (int col = 0; col != Chip8Emulator.Core.Cpu.SCREEN_WIDTH; col++)
            for (int row = 0; row != Chip8Emulator.Core.Cpu.SCREEN_HEIGHT; row++)
            {
                if (!_currFrame[col, row])
                    continue;
                await _offscreenCanvasContext.FillRectAsync(col * spriteWidth, row* spriteHeight, spriteWidth, spriteHeight);
            }

        await _offscreenCanvasContext.EndBatchAsync();
    }
 
    private async Task RenderFrame()
    {
        await _outputCanvasContext.ClearRectAsync(0, 0, _canvasWidth, _canvasHeight);
        await _outputCanvasContext.DrawImageAsync(_offscreenCanvasContext.Canvas, 0, 0);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        _renderer = new Chip8Emulator.Core.LambdaRenderer(async data => await UpdateFrame(data), async()=> await RenderFrame());
        _cpu = new Core.Cpu(_renderer, new Chip8Emulator.Core.DefaultSoundPlayer());

        _outputCanvasContext = await _canvasReference.CreateCanvas2DAsync();
        _offscreenCanvasContext = await _offscreenCanvasReference.CreateCanvas2DAsync();

        await JsRuntime.InvokeAsync<object>("initGame", DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async ValueTask GameLoop(float timeStamp, int width, int height)
    {
        _canvasWidth = width;
        _canvasHeight = height;

        _cpu.Tick();

        _renderer.Render();
    }

    [JSInvokable]
    public void OnKeyDown(int keyCode) {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyDown(_keyMappings[keyCode]);
    }

    [JSInvokable]
    public void OnKeyUp(int keyCode) {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyUp(_keyMappings[keyCode]);
    }
}
@page "/"

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient;

<div id="controls">
    <select @bind="_selectedRom">
        <option>-- Select a ROM --</option>
        @foreach (var rom in _roms)
        {
            <option value="@rom">@rom</option>
        }
    </select>
    <button @onclick="LoadRom">Load</button>

    <label for="tickInterval">Tick interval (ms)</label>
    <input type="number" min="1" @bind="_tickInterval" id="tickInterval" />
    <button @onclick="SetCPUInterval">Set Interval</button>
</div>

<div id="main-canvas-container" class="canvas-container">
    <CanvasManager @ref="_canvasManager" />
</div>

@code{
    CanvasManager _canvasManager;
    IRenderContext _mainRenderContext;

    CanvasBase _offscreenCanvas;
    IRenderContext _offscreenRenderContext;

    int _canvasWidth = 800;
    int _canvasHeight = 400;

    Core.Cpu _cpu;
    Core.IRenderer _renderer;
    System.Timers.Timer _cpuTickTimer;
    int _tickInterval = 10;

    string[] _roms = new[]{
        "15PUZZLE",
        "BRIX",
        "HIDDEN",
        "MAZE",
        "PONG",
        "SYZYGY",
        "TICTAC",
        "VERS",
        "BLINKY",
        "CONNECT4",
        "INVADERS",
        "MERLIN",
        "PONG2",
        "TANK",
        "UFO",
        "WIPEOFF",
        "BLITZ",
        "GUESS",
        "KALEID",
        "MISSILE",
        "PUZZLE",
        "TETRIS",
        "VBRIX"
    };
    string _selectedRom;

    private readonly Dictionary<int, Core.Keys> _keyMappings = new Dictionary<int, Core.Keys>() {
            { 49, Core.Keys.Number1 }, // 1
            { 50, Core.Keys.Number2 }, // 2
            { 51, Core.Keys.Number3 }, // 3
            { 52, Core.Keys.C }, // 4
            { 81, Core.Keys.Number4 }, // q
            { 87, Core.Keys.Number5 }, // w
            { 69, Core.Keys.Number6 }, // e
            { 82, Core.Keys.D }, // r
            { 65, Core.Keys.Number7 }, // a
            { 83, Core.Keys.Number8 }, // s
            { 68, Core.Keys.Number9 }, // d
            { 70, Core.Keys.E }, // f
            { 90, Core.Keys.A }, // z
            { 88, Core.Keys.Number0 }, // x
            { 67, Core.Keys.B }, // c
            { 86, Core.Keys.F } // v
    };

    private async Task LoadRom()
    {
        _cpuTickTimer.Enabled = false;

        if (string.IsNullOrWhiteSpace(_selectedRom))
            return;

        var romUrl = $"roms/{_selectedRom}";
        using var response = await HttpClient.GetAsync(romUrl);
        if (!response.IsSuccessStatusCode)
        {
            Console.WriteLine($"Failed to load ROM from {romUrl}");
            return;
        }

        using var romData = await response.Content.ReadAsStreamAsync();
        _cpu.LoadRom(romData);

        _cpuTickTimer.Enabled = true;
    }

    private void UpdateFrame(bool[,] data)
    {
        _offscreenRenderContext.ClearRect(0, 0, Chip8Emulator.Core.Constants.SCREEN_WIDTH, Chip8Emulator.Core.Constants.SCREEN_HEIGHT);

        var spriteWidth = 1;
        var spriteHeight = 1;

        _offscreenRenderContext.FillStyle = "green";

        for (int col = 0; col != Chip8Emulator.Core.Constants.SCREEN_WIDTH; col++)
            for (int row = 0; row != Chip8Emulator.Core.Constants.SCREEN_HEIGHT; row++)
            {
                if (data[col, row])
                    _offscreenRenderContext.FillRect(col, row, spriteWidth, spriteHeight);
            }
    }

    private void SetCPUInterval()
        => _cpuTickTimer.Interval = _tickInterval;

    private void OnMainCanvasReady(CanvasBase canvas)
    {
        _mainRenderContext = canvas.RenderContext;
    }

    private void OnMainCanvasResize(Size windowSize)
    {
        _canvasWidth = windowSize.Width;
        _canvasHeight = windowSize.Height;
    }

    private void OnMainCanvasFrameReady(float timestamp)
    {
        _mainRenderContext.ClearRect(0, 0, _canvasWidth, _canvasHeight);

        _mainRenderContext.DrawImage(_offscreenCanvas.ElementReference, 0, 0, _canvasWidth, _canvasHeight);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender)
            return;

        _canvasManager.CreateCanvas("mainCanvas", new CanvasCreationOptions()
        {
            Width = _canvasWidth,
            Height = _canvasHeight,
            Hidden = false,
            OnCanvasReady = this.OnMainCanvasReady,
            OnResize = this.OnMainCanvasResize,
            OnFrameReady = this.OnMainCanvasFrameReady
        });

        _canvasManager.CreateCanvas("offscreenCanvas", new CanvasCreationOptions()
        {
            Width = Chip8Emulator.Core.Constants.SCREEN_WIDTH,
            Height = Chip8Emulator.Core.Constants.SCREEN_HEIGHT,
            Hidden = true,
            OnCanvasReady = (canvas) =>
            {
                _offscreenCanvas = canvas;
                _offscreenRenderContext = canvas.RenderContext;
            },
        });

        _renderer = new Chip8Emulator.Core.LambdaRenderer(data => UpdateFrame(data));
        _cpu = new Core.Cpu(_renderer, new Chip8Emulator.Core.DefaultSoundPlayer());

        _cpuTickTimer = new System.Timers.Timer();
        this.SetCPUInterval();
        _cpuTickTimer.Elapsed += (s, e) =>
        {
            _cpu.Tick();
        };
    }

    [JSInvokable]
    public void OnKeyDown(int keyCode)
    {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyDown(_keyMappings[keyCode]);
    }

    [JSInvokable]
    public void OnKeyUp(int keyCode)
    {
        if (_keyMappings.ContainsKey(keyCode))
            _cpu.SetKeyUp(_keyMappings[keyCode]);
    }
}